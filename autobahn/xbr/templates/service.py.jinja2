{% if is_first_by_category %}
##
## service types (aka "APIs")
##
import abc
from pprint import pformat

from txaio.interfaces import ILogger
from autobahn.wamp.types import PublishOptions, SubscribeOptions, EventDetails
from autobahn.wamp.request import Publication
from autobahn.wamp.interfaces import ISession
from autobahn.xbr import IDelegate


{% endif %}
class {{ metadata.classname }}(object):
    """
    {{ metadata.docs }}

    @interface: "{{ metadata.attrs.uuid }}"
    """
    __slots__ = [
        'log',
        '_x_api_id',
        '_x_prefix',
        '_x_session',
        '_x_delegate',
    ]

    def __init__(self, prefix: str, log: Optional[ILogger]=None):
        """

        :param prefix: The URI prefix under which this API will be instantiated under on the realm joined.
        :param log: If provided, log to this logger, else create a new one internally.
        """
        if log:
            self.log = log
        else:
            import txaio
            self.log = txaio.make_logger()
        self._x_api_id = uuid.UUID('{{ metadata.attrs.uuid }}')
        self._x_prefix = prefix
        self._x_session = None
        self._x_delegate = None

    @property
    def api(self) -> Optional[uuid.UUID]:
        """
        WAMP session this API is attached to.
        """
        return self._x_api_id

    @property
    def prefix(self) -> Optional[str]:
        """
        WAMP URI prefix under which this API is instantiated.
        """
        return self._x_prefix

    @property
    def session(self) -> Optional[ISession]:
        """
        WAMP session this API is attached to.
        """
        return self._x_session

    @property
    def delegate(self) -> Optional[IDelegate]:
        """
        XBR (buyer/seller) delegate this API is attached to.
        """
        return self._x_delegate

    @property
    def is_attached(self) -> bool:
        """
        Flag indicating whether this API instance is currently attached to a session/delegate.
        """
        return self._x_session is not None and self._x_delegate is not None

    async def attach(self, session, delegate):
        """
        Attach this API instance with the given session and delegate, and under the given WAMP URI prefix.

        :param session: WAMP session this API instance is attached to.
        :param delegate: XBR (buyer/seller) delegate used by this API instance.
        """
        assert not self.is_attached

        self._x_session = session
        self._x_delegate = delegate
        subscriptions = []
        {% for call_name in metadata.calls_by_id %}
        {% if metadata.calls[call_name].attrs['type'] == 'topic' %}

        async def do_receive_{{ call_name }}(key_id, enc_ser, ciphertext, details=None):
            print('Received event {}, encrypted with key_id={}'.format(details.publication, uuid.UUID(bytes=key_id)))
            try:
                payload = await self._x_delegate.unwrap(key_id, enc_ser, ciphertext)
                obj = {{ repo.objs[metadata.calls[call_name].request.name].map('python') }}.parse(payload)
            except:
                self.log.failure()
            else:
                print('Unencrypted event payload: {}'.format(pformat(obj)))
                self.receive_{{ call_name }}(obj)

        topic = '{}.{{ call_name }}'.format(self._x_prefix)
        sub = await self._x_session.subscribe(do_receive_{{ call_name }}, topic, options=SubscribeOptions(details=True))
        subscriptions.append(sub)
        {% endif %}
        {% endfor %}

        for sub in subscriptions:
            self.log.info('Subscription {} created for "{}"'.format(sub.id, sub.topic))

    async def detach(self):
        """
        Detach this API instance from the session and delegate.
        """
        assert self.is_attached
        if self._x_session.is_attached():
            await self._x_session.leave()
        self._x_session = None
        self._x_delegate = None

    {% for call_name in metadata.calls_by_id %}
    {% if metadata.calls[call_name].attrs['type'] == 'topic' %}
    async def publish_{{ call_name }}(self, evt: {{ repo.objs[metadata.calls[call_name].request.name].map('python') }}, options: Optional[PublishOptions] = None) -> Publication:
        """
        Publish - {{ metadata.calls[call_name].docs }}
        """
        assert self.is_attached

        topic = '{}.{{ call_name }}'.format(self._x_prefix)
        payload = evt.marshal()
        key_id, enc_ser, ciphertext = await self._x_delegate.wrap(self._x_api_id, topic, payload)
        pub = await self._x_session.publish(topic, key_id, enc_ser, ciphertext, options=options)
        return pub

    def receive_{{ call_name }}(self, evt: {{ repo.objs[metadata.calls[call_name].request.name].map('python') }}, details: Optional[EventDetails] = None):
        """
        Receive - {{ metadata.calls[call_name].docs }}
        """
        raise NotImplementedError('event handler for "{{ call_name }}" not implemented')

    {% endif %}
    {% endfor %}
