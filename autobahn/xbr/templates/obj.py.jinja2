import uuid
from typing import Dict, List, Optional

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

from autobahn.xbr import FbsType


class {{ metadata.classname }}(object):
    """
    {{ docs }}
    """
    __slots__ = [
        '_tab',
        '_from_fbs',
        {% for field_name in metadata.fields %}'_{{ metadata.fields[field_name].name }}',
        {% endfor %}
    ]

    def __init__(self, from_fbs=None):
        """

        :param from_fbs: FlatBuffers raw buffer to load. A new object of this class
            is created that wraps the data contained in the FlatBuffers raw buffer.
        """
        self._from_fbs = from_fbs
        {% for field_name in metadata.fields %}
        # {{ metadata.fields[field_name]['docs'] }}
        self._{{ metadata.fields[field_name].name }} = None
        {% endfor %}

    @classmethod
    def GetRootAs{{ metadata.classname }}(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = {{ metadata.classname }}()
        x.Init(buf, n + offset)
        return x

    # HomeDevice
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def marshal(self) -> Dict:
        """
        Marshal all data contained in this typed native object into a generic object.

        :returns: Generic object that can be serialized to bytes using eg ``json.dumps``.
        """
        obj = {
            {% for field_name in metadata.fields %}'{{ metadata.fields[field_name].name }}': self.{{ metadata.fields[field_name].name }},
            {% endfor %}
        }
        return obj

    def __str__(self) -> str:
        """
        Return string representation of this object, suitable for eg logging.

        :returns: String representation of this object.
        """
        import pprint
        return '\n{}\n'.format(pprint.pformat(self.marshal()))


    {% for field_name in metadata.fields %}
    @property
    def {{ metadata.fields[field_name].name }}(self) -> {{ metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) }}:
        """
        {{ metadata.fields[field_name]['docs'] }}
        """
        if self._{{ metadata.fields[field_name].name }} is None and self._tab:
            o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset({{ metadata.fields[field_name].offset }}))
            value = None
            {% if metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) == 'str' %}
            # access type "string" attribute:
            if o != 0:
                value = self._tab.String(o + self._tab.Pos).decode('utf8')
            {% elif metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) == 'bytes' %}
            # access type "bytes" attribute:
            if o != 0:
                _off = self._tab.Vector(o)
                _len = self._tab.VectorLen(o)
                value = memoryview(self._tab.Bytes)[_off:_off + _len]
            {% elif metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) in ['int', 'float', 'double'] %}
            # access type "int|float|double" attribute:
            if o != 0:
                value = self._tab.Get(flatbuffers.number_types.{{ FbsType.FBS2FLAGS[metadata.fields[field_name].type.basetype] }}, o + self._tab.Pos)
            {% elif metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) == 'uuid.UUID' %}
            # access type "uuid.UUID" attribute:
            if o != 0:
                _off = self._tab.Vector(o)
                _len = self._tab.VectorLen(o)
                value = memoryview(self._tab.Bytes)[_off:_off + _len]
                if value is not None:
                    value = uuid.UUID(bytes=value)
                else:
                    value = uuid.UUID(bytes=b'\x00' * 20)
            {% elif metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) == 'np.datetime64' %}
            # access type "np.datetime64" attribute:
            if o != 0:
                value = self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
                if value is not None:
                    value = np.datetime64(value, 'ns')
                else:
                    value = np.datetime64(0, 'ns')
            {% else %}# FIXME: load value for type "{{ metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) }}"
            raise NotImplementedError('implement processing of FlatBuffers type "{}"'.format(metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True)))
            {% endif %}
            if value is not None:
                self._{{ metadata.fields[field_name].name }} = value
        return self._{{ metadata.fields[field_name].name }}

    @{{ metadata.fields[field_name].name }}.setter
    def {{ metadata.fields[field_name].name }}(self, value: {{ metadata.fields[field_name].type.map('python', metadata.fields[field_name].attrs, True) }}):
        # FIXME: assert type of value
        self._{{ metadata.fields[field_name].name }} = value
    {% endfor %}

    @staticmethod
    def cast(buf: bytes) -> object:
        """
        Cast a FlatBuffers raw input buffer as a typed object of this class.

        :param buf: The raw input buffer to cast.

        :returns: New native object that wraps the FlatBuffers raw buffer.
        """
        raise NotImplementedError()

    def build(self, builder):
        """
        Build a FlatBuffers raw output buffer from this typed object.

        :returns: Constructs the FlatBuffers using the builder and
            returns ``builder.EndObject()``.
        """
        raise NotImplementedError()
